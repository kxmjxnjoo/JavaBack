package days15;
// - 일반 객체의 생성과정
// 1. 멤버 필드 메모리 로딩
// 2. 생성자 호출
// 
// ### 상속관계에서의 객체 생성과정
// 
// 1. 멤버 필드의 메모리 로딩 - 부모/자식클래스의 모든 멤버필드가 메모리 로딩
// 2. 생성자 호출(자식 클래스의 생성자 먼저호출)
// 3. 자식 클래스 생성자의 첫 번째 실행 코드인 super()에 의해 부모클래스의 생성자 호출, 
//     super()라는 명령은 따로 쓰지 않아도 이미 존재하며 부모 클래스가 있다면 자동 호출되는 명령
// 4. 자식 클래스의 생성자 나머지 코드들 실행 - 부모 클래스의 priavte멤버와 같은 경우 
//     자식클래스에서 초기화를 할 수 없기 때문에 부모 클래스 생성자를 통해 초기화를 실행
	
class SuperB {
	int superNum;
	// 매개변수가 있는 생성자로 자식생성자가 오버로딩 된 경우
	// this()로 형제 생성자를 호출하지 않은 경우
	public SuperB() {
		System.out.println("부모클래스의 생성자 실행");
	}
}
class SubB extends SuperB { // SuperB 클래스 상속
	int subNum;
	// 생성자를 별도로 꺼내서 정의 하지 않았다면 디폴트 생성자가 존재할 것
	// 그의  첫번째 명령은 아래와 같이 super();가 자리하고 있음
	// SubB() {
	// 		super();
	// }
	SubB() { // 디폴트 생성자를 별도로 꺼내서 정의한 경우
		super();
		// 자식 클래스에서 부모클래스 생성자 호출은 super();라고 명령하며 반드시 첫번째 실행코드로 씁니다
		// 다만 부모 클래스의 생성자가 오버로딩 되거나 하지 않았다면 쓰지 않아도 super();명령은 실행됨
		// 부모 클래스 생성자가 디폴트생성자만 있을시 super(); 명령 생략-자동호출
		// super(); 명령은 실행됩니다		super(); 명령 생략- 자동 호출
		// super(); 명령이 감춰지지 않아야하며, 꼭 써야하는 경우
		// 부모 클래스의 생성자가 오버로딩 또는 대체되어서 디폴트 생성자가 없을 때
		System.out.println("자식클래스의 디폴트 생성자 실행");
	}
		public SubB(int subNum) { // 오버로딩된 자식 클래스 생성자
			// 자식 클래스의 오버로딩된 생성자의 첫번째 실행코드는 super() 또는 
			// this()를 코딩하는데 그 둘을 같이 실행할 수는 없음
			// 현재 클래스의 매개벼수가 없는 생성자를 this()로 호출하고 그 안에서 super()가 실행되도록함
			this();
			System.out.println("자식클래스의 오버로딩된 생성자 실행(this()O)");
			// 부모나 형제 생성자에 매개변수가 있는 경우 반드시
			// 호출하려는 super() 또는 this()매개변수에 맞춰 전달인수를 전달
				
		}
		public SubB(int i, int j) {
			System.out.println("자식클래스의 오버로딩된 생성자 실행(this()X)");
	}
}
public class Extends04 {

	public static void main(String[] args) {
		SubB b = new SubB();
		System.out.println();
		SubB c = new SubB(20);
		System.out.println();
		SubB d = new SubB(20,40);

	}
}

// 1. 객체 생성(자식클래스 생성자 호출)
// 2. 자식 클래스 내부에서 부모 클래스의 생성자 로출
// 3. 부모클래스 생성자 실행
// # 2번의 부모클래스 호출은스지 않아도 자동으로 자식 클래스의 내부 첫번째 명령으로 실행됨

// 4. 자식 클래스의 생성자가 오버로딩 된 경우, 모든 자식 클래스 생성자들은
// this()와 super() 명령 중 하나를 선택해야하는데, 안쓰면 super();가 자동적용됨
// 5. this()를 쓰는 경우 호출된 형제 생성자에서 super를 호출해줌
